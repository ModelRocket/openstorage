// Code generated by protoc-gen-go.
// source: openstorage/openstorage.proto
// DO NOT EDIT!

package openstorage

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// discarding unused import google_api1 "google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type FSType int32

const (
	FSType_FS_TYPE_NONE  FSType = 0
	FSType_FS_TYPE_EXT4  FSType = 1
	FSType_FS_TYPE_XFS   FSType = 2
	FSType_FS_TYPE_ZFS   FSType = 3
	FSType_FS_TYPE_NFS   FSType = 4
	FSType_FS_TYPE_BTRFS FSType = 5
)

var FSType_name = map[int32]string{
	0: "FS_TYPE_NONE",
	1: "FS_TYPE_EXT4",
	2: "FS_TYPE_XFS",
	3: "FS_TYPE_ZFS",
	4: "FS_TYPE_NFS",
	5: "FS_TYPE_BTRFS",
}
var FSType_value = map[string]int32{
	"FS_TYPE_NONE":  0,
	"FS_TYPE_EXT4":  1,
	"FS_TYPE_XFS":   2,
	"FS_TYPE_ZFS":   3,
	"FS_TYPE_NFS":   4,
	"FS_TYPE_BTRFS": 5,
}

func (x FSType) String() string {
	return proto.EnumName(FSType_name, int32(x))
}

// TODO(pedge): originally this was 0, 5, 9, was that
// just for future spacing?
type COS int32

const (
	COS_COS_NONE   COS = 0
	COS_COS_MEDIUM COS = 1
	COS_COS_MAX    COS = 2
)

var COS_name = map[int32]string{
	0: "COS_NONE",
	1: "COS_MEDIUM",
	2: "COS_MAX",
}
var COS_value = map[string]int32{
	"COS_NONE":   0,
	"COS_MEDIUM": 1,
	"COS_MAX":    2,
}

func (x COS) String() string {
	return proto.EnumName(COS_name, int32(x))
}

// TODO(pedge): want to understand name better
type VolumeLocator struct {
	Name   string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Labels map[string]string `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VolumeLocator) Reset()         { *m = VolumeLocator{} }
func (m *VolumeLocator) String() string { return proto.CompactTextString(m) }
func (*VolumeLocator) ProtoMessage()    {}

func (m *VolumeLocator) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// TODO(pedge): Source or volumeSource
type VolumeSource struct {
	// TODO(pedge): message Volume { string id = 1 ; } ?
	ParentVolumeId string `protobuf:"bytes,1,opt,name=parent_volume_id" json:"parent_volume_id,omitempty"`
	// TODO(pedge): typed url? more explanation needed
	SeedUri string `protobuf:"bytes,2,opt,name=seed_uri" json:"seed_uri,omitempty"`
}

func (m *VolumeSource) Reset()         { *m = VolumeSource{} }
func (m *VolumeSource) String() string { return proto.CompactTextString(m) }
func (*VolumeSource) ProtoMessage()    {}

type VolumeSpec struct {
	Ephemeral bool `protobuf:"varint,1,opt,name=ephemeral" json:"ephemeral,omitempty"`
	// TODO(pedge): size? size_bytes?
	SizeBytes uint64 `protobuf:"varint,2,opt,name=size_bytes" json:"size_bytes,omitempty"`
	FsType    FSType `protobuf:"varint,3,opt,name=fs_type,enum=openstorage.FSType" json:"fs_type,omitempty"`
	// TODO(pedge): uint64? uint32? need to understand what 0 value means
	BlockSize int64 `protobuf:"varint,4,opt,name=block_size" json:"block_size,omitempty"`
	// TODO(pedge): type? enum? range? bounds?
	HaLevel int32 `protobuf:"varint,5,opt,name=ha_level" json:"ha_level,omitempty"`
	// TODO(pedge): cos? volume_cos? VolumeCOS for enum name?
	Cos COS `protobuf:"varint,6,opt,name=cos,enum=openstorage.COS" json:"cos,omitempty"`
	// TODO(pege): dedupe?
	Deduplicate         bool   `protobuf:"varint,7,opt,name=deduplicate" json:"deduplicate,omitempty"`
	SnapshotIntervalMin uint32 `protobuf:"varint,8,opt,name=snapshot_interval_min" json:"snapshot_interval_min,omitempty"`
	// TODO(pedge): config_labels?
	Labels map[string]string `protobuf:"bytes,9,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VolumeSpec) Reset()         { *m = VolumeSpec{} }
func (m *VolumeSpec) String() string { return proto.CompactTextString(m) }
func (*VolumeSpec) ProtoMessage()    {}

func (m *VolumeSpec) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

type VolumeCreateRequest struct {
	VolumeLocator *VolumeLocator `protobuf:"bytes,1,opt,name=volume_locator" json:"volume_locator,omitempty"`
	VolumeSource  *VolumeSource  `protobuf:"bytes,2,opt,name=volume_source" json:"volume_source,omitempty"`
	VolumeSpec    *VolumeSpec    `protobuf:"bytes,3,opt,name=volume_spec" json:"volume_spec,omitempty"`
}

func (m *VolumeCreateRequest) Reset()         { *m = VolumeCreateRequest{} }
func (m *VolumeCreateRequest) String() string { return proto.CompactTextString(m) }
func (*VolumeCreateRequest) ProtoMessage()    {}

func (m *VolumeCreateRequest) GetVolumeLocator() *VolumeLocator {
	if m != nil {
		return m.VolumeLocator
	}
	return nil
}

func (m *VolumeCreateRequest) GetVolumeSource() *VolumeSource {
	if m != nil {
		return m.VolumeSource
	}
	return nil
}

func (m *VolumeCreateRequest) GetVolumeSpec() *VolumeSpec {
	if m != nil {
		return m.VolumeSpec
	}
	return nil
}

type VolumeCreateResponse struct {
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id" json:"volume_id,omitempty"`
}

func (m *VolumeCreateResponse) Reset()         { *m = VolumeCreateResponse{} }
func (m *VolumeCreateResponse) String() string { return proto.CompactTextString(m) }
func (*VolumeCreateResponse) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("openstorage.FSType", FSType_name, FSType_value)
	proto.RegisterEnum("openstorage.COS", COS_name, COS_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for API service

type APIClient interface {
	VolumeCreate(ctx context.Context, in *VolumeCreateRequest, opts ...grpc.CallOption) (*VolumeCreateResponse, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) VolumeCreate(ctx context.Context, in *VolumeCreateRequest, opts ...grpc.CallOption) (*VolumeCreateResponse, error) {
	out := new(VolumeCreateResponse)
	err := grpc.Invoke(ctx, "/openstorage.API/VolumeCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for API service

type APIServer interface {
	VolumeCreate(context.Context, *VolumeCreateRequest) (*VolumeCreateResponse, error)
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_VolumeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(VolumeCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(APIServer).VolumeCreate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openstorage.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VolumeCreate",
			Handler:    _API_VolumeCreate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
